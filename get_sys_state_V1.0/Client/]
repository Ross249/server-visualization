#include <linux/sysinfo.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <strings.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/sysinfo.h>

#include "../inc/Bald_Get_Sys_Info.h"
#include "../inc/Bald_cJSON.h"

#define MAX_BUFF_SIZE 1024

/******************************字符串处理函数******************************/
void GET_SYS_Del_Str_Useless(char *pcData)
{
	uint32_t u32Len = strlen(pcData);
	char aTempData[u32Len];
	memcpy(aTempData, pcData, u32Len);

	uint32_t i = 0,j = u32Len-1;
	while( i < u32Len && (pcData[i] == ' '||pcData[i] == '\n') )i++;
	while( j >= 0	  && (pcData[j] == ' '||pcData[j] == '\n') )j--;

	memset(pcData,0,u32Len);
	memcpy(pcData,aTempData+i, j-i+1);
}

	

/******************************只获取一次******************************/

int8_t GET_SYS_CpuNum(char *pcData)
{
	FILE *fp = popen("grep -c \"model name\" /proc/cpuinfo","r");	
	fread(pcData, MAX_BUFF_SIZE, 1, fp);
	fclose(fp);
	return 0;
}

int8_t GET_SYS_HostName(char *pcData)
{
	int fd = open("/etc/hostname",O_RDONLY);	
	read(fd,pcData,MAX_BUFF_SIZE);
	GET_SYS_Del_Str_Useless(pcData);
	close(fd);
	return 0;
}

int8_t GET_SYS_UserName(char *pcData)
{
	FILE *fp = popen("whoami","r");
	fread(pcData,MAX_BUFF_SIZE,1,fp);
	GET_SYS_Del_Str_Useless(pcData);
	fclose(fp);
	return 0;
}

int8_t GET_SYS_Version(char *pcData)
{
	FILE *fp = popen("lsb_release -a|sed -n 3p |awk '{print$2}' 2>/dev/null","r");
	fread(pcData,MAX_BUFF_SIZE,1,fp);
	GET_SYS_Del_Str_Useless(pcData);
	fclose(fp);
	return 0;
}

int8_t GET_SYS_Distributor(char *pcData)
{
	FILE *fp = popen("lsb_release -a|sed -n 1p|awk '{print$3}' 2>/dev/null","r");
	fread(pcData,MAX_BUFF_SIZE,1,fp);
	GET_SYS_Del_Str_Useless(pcData);
	fclose(fp);
	return 0;
}

cJSON *GET_SYS_GetOnce()
{
	cJSON *cjRoot = cJSON_CreateObject();
	char aTempBuff[MAX_BUFF_SIZE];	
	bzero(aTempBuff, MAX_BUFF_SIZE);

	//version
	if( GET_SYS_Version(aTempBuff) == 0)
	{
		cJSON_AddStringToObject(cjRoot, "version",(aTempBuff));	
	}

	//distributor
	if( GET_SYS_Distributor(aTempBuff) == 0)
	{
		cJSON_AddStringToObject(cjRoot, "distributor",(aTempBuff));	
	}

	//cpu数
	if( GET_SYS_CpuNum(aTempBuff) == 0)
	{
		cJSON_AddNumberToObject(cjRoot, "cpu_num", atoi(aTempBuff));	
	}

	bzero(aTempBuff, MAX_BUFF_SIZE);

	//hostname
	if( GET_SYS_HostName(aTempBuff) == 0)
	{
		cJSON_AddStringToObject(cjRoot, "host_name",(aTempBuff));	
	}
	
	bzero(aTempBuff, MAX_BUFF_SIZE);

	//username
	if( GET_SYS_UserName(aTempBuff) == 0)
	{
		cJSON_AddStringToObject(cjRoot, "user_name",(aTempBuff));	
	}

	return cjRoot;
}

/******************************开机时间******************************/
int16_t GET_SYS_UpTime(time_t *u32Time)
{
	struct sysinfo stSysInfo;
	if (sysinfo(&stSysInfo)) {
		return -1;
    }
	*u32Time = stSysInfo.uptime;

	return 0;
}


cJSON *GET_SYS_GetTime(void)
{
	cJSON *cjRoot = cJSON_CreateObject();

	char aTempBuff[MAX_BUFF_SIZE];	
	bzero(aTempBuff, MAX_BUFF_SIZE);

	//uptime
	time_t u32UpTime;	
	if( GET_SYS_UpTime(&u32UpTime) == 0)
	{
		cJSON_AddNumberToObject(cjRoot, "allsec", u32UpTime);
		cJSON_AddNumberToObject(cjRoot, "day", (uint32_t)u32UpTime/86400);
		cJSON_AddNumberToObject(cjRoot, "hour", (uint32_t)u32UpTime%86400/3600);
		cJSON_AddNumberToObject(cjRoot, "min", (uint32_t)u32UpTime%86400%3600/60);
		cJSON_AddNumberToObject(cjRoot, "sec", (uint32_t)u32UpTime%86400%3600%60);
	}

	return cjRoot;
}


/******************************内存******************************/

#define MEM_NUM 15
int16_t GET_SYS_Mem(uint32_t au32[MEM_NUM])
{
	char aTempBuff[MAX_BUFF_SIZE];
	//按kB为单位获取 内存信息 需要兼容
	FILE *fp = popen("free -lk |sed 1d |awk '{print$2,$3,$4,$5,$6}'|tr '\n' ' '","r");	
	fread(aTempBuff, MAX_BUFF_SIZE, 1, fp);
	uint32_t u32Len = strlen(aTempBuff);
	if(u32Len == 0)
	{
		fclose(fp);
		printf("read %d\n",u32Len);
		return -1;
	}

	uint32_t i = 0,j = 0;
	for ( j = 0 ; j < MEM_NUM; j++ )
	{
		sscanf(&aTempBuff[i], "%d[^ ]",&au32[j]);
		while(i < u32Len && aTempBuff[i] != ' ')i++;
		i++;
	}


	fclose(fp);
	return 0;
}

cJSON *GET_SYS_GetMem(void)
{
	cJSON *cjRoot = cJSON_CreateObject();
	uint32_t au32Mem[MEM_NUM];
	bzero(au32Mem, MEM_NUM);
	GET_SYS_Mem(au32Mem);

	cJSON_AddNumberToObject(cjRoot, "total_mem",au32Mem[0]);
	cJSON_AddNumberToObject(cjRoot, "used_mem",au32Mem[1]);
	cJSON_AddNumberToObject(cjRoot, "free_mem",au32Mem[2]);
	cJSON_AddNumberToObject(cjRoot, "shared_mem",au32Mem[3]);
	cJSON_AddNumberToObject(cjRoot, "buff/cache_mem",au32Mem[4]);
	cJSON_AddNumberToObject(cjRoot, "available_mem",au32Mem[5]);
	cJSON_AddNumberToObject(cjRoot, "total_low",au32Mem[6]);
	cJSON_AddNumberToObject(cjRoot, "used_low",au32Mem[7]);
	cJSON_AddNumberToObject(cjRoot, "free_low",au32Mem[8]);
	cJSON_AddNumberToObject(cjRoot, "total_high",au32Mem[9]);
	cJSON_AddNumberToObject(cjRoot, "used_high",au32Mem[10]);
	cJSON_AddNumberToObject(cjRoot, "free_high",au32Mem[11]);
	cJSON_AddNumberToObject(cjRoot, "total_sawp",au32Mem[12]);
	cJSON_AddNumberToObject(cjRoot, "used_sawp",au32Mem[13]);
	cJSON_AddNumberToObject(cjRoot, "free_swap",au32Mem[14]);

	return cjRoot;
}


/******************************cpu使用率******************************/

int16_t GET_SYS_UserCpu(char * pcData)
{
	FILE *fp = popen("top -b -n 1 | grep Cpu | awk '{print $2}' |tr -d '\n' ","r");	
	int ret = fread(pcData, MAX_BUFF_SIZE, 1, fp);
	/** printf("%s\n",pcData); */
	if(ret != 0 )
	{
		fclose(fp);
		return -1;
	}

	return 0;

}

int16_t GET_SYS_SysCpu(char * pcData)
{
	FILE *fp = popen("top -b -n 1 | grep Cpu | awk '{print $4}' |tr -d '\n' ","r");	
	int ret = fread(pcData, MAX_BUFF_SIZE, 1, fp);
	/** printf("%s\n",pcData); */
	if(ret != 0 )
	{
		fclose(fp);
		return -1;
	}
	return 0;
}

int16_t GET_SYS_NiceCpu(char * pcData)
{
	FILE *fp = popen("top -b -n 1 | grep Cpu | awk '{print $6}' |tr -d '\n' ","r");	
	int ret = fread(pcData, MAX_BUFF_SIZE, 1, fp);
	/** printf("%s\n",pcData); */
	if(ret != 0 )
	{
		fclose(fp);
		return -1;
	}
	return 0;
}

typedef struct cpu_jeffies_st
{
	uint32_t u32User;
	uint32_t u32Nice;
	uint32_t u32Sys;
	uint32_t u32Idle;
	uint32_t u32Iowait;
	uint32_t u32Irq;
	uint32_t u32Softirq;
}CPU_JEFFIES_ST;

typedef struct cpu_info_st
{
	uint32_t u32CpuNum;
	CPU_JEFFIES_ST stCpu[0];
}CPU_INFO_ST;


int16_t GET_SYS_Proc_Stat()
{

}

cJSON *GET_SYS_GetCpu(void)
{
	cJSON *cjRoot = cJSON_CreateObject();
	


	//user cpu
	char aData[MAX_BUFF_SIZE];
	if(	GET_SYS_UserCpu(aData) != -1)
	{
		cJSON_AddStringToObject(cjRoot, "us", aData);
	}

	//sys cpu
	if(	GET_SYS_SysCpu(aData) != -1)
	{
		cJSON_AddStringToObject(cjRoot, "sy", aData);
	}

	//nice cpu
	if(	GET_SYS_NiceCpu(aData) != -1)
	{
		cJSON_AddStringToObject(cjRoot, "ni", aData);
	}
	return cjRoot;
}


























